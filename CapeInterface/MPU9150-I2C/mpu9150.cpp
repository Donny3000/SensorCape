#include "mpu9150.h"

using namespace Sensors;

MPU9150::MPU9150(const __u8 bus, const __u16 address)
{
    // Open the bus and set the address to the MPU-9150
    I2CInterface::Instance()->OpenI2CInterface( bus );
    I2CInterface::Instance()->SetDeviceAddress( address );

    // Begin configuring the MPU-9150 for use

    /*
     * Sample Rate Divider: Address 0x19
     *
     * Description:
     * ------------
     * This register specifies the divider from the gyroscope output rate used
     * to generate the Sample Rate for the MPU-9150.
     *
     * The sensor register output,FIFO output and DMP sampling are all based on
     * the Sample Rate. The Sample Rate is generated by dividing the gyroscope
     * output rate by SMPLRT_DIV:
     *          Sample Rate = Gyroscope Output Rate / (1 + SMPLRT_DIV)
     * where Gyroscope Output Rate = 8kHz when the DLPF is disabled
     * (DLPF_CFG = 0 or 7), and 1kHz when the DLPF is enabled (see Register 26).
     *
     * Note: The accelerometer output rate is 1kHz. This means that for a
     * Sample Rate greater than 1kHz, the same accelerometer sample may be
     * output to the FIFO, DMP, and sensor registers more than once.
     *
     * Usage: We will set the value to 8 to get a sensor sample rate of 1kHz.
     * Since the accelerometer sample rate is 1kHz, we will set the sample rate
     * of the other data to 1kHz too.
     */
    I2CInterface::Instance()->write8(0x19, 0x08);

    /*
     * Configuration: Address: 0x1A
     *
     * Description:
     * ------------
     * This register configures the external Frame Synchronization (FSYNC) pin
     * sampling and the Digital Low Pass Filter (DLPF) setting for both the
     * gyroscopes and accelerometers.
     *
     * An external signal connected to the FSYNC pin can be sampled by
     * configuring EXT_SYNC_SET.
     *
     * Signal changes to the FSYNC pin are latched so that short strobes may be
     * captured. The latched FSYNC signal will be sampled at the Sampling Rate,
     * as defined in register 25. After sampling, the latch will reset to the
     * current FSYNC signal state.
     *
     * The sampled value will be reported in place of the least significant bit
     * in a sensor data register determined by the value of EXT_SYNC_SET
     * according to the following table.
     *
     *                  -------------------------------------
     *                  | EXT_SYNC_SET | FSYNC Bit Location |
     *                  -------------------------------------
     *                  |       0      | Input Disabled     |
     *                  |       1      | TEMP_OUT_L[0]      |
     *                  |       2      | GYRO_XOUT_L[0]     |
     *                  |       3      | GYRO_YOUT_L[0]     |
     *                  |       4      | GYRO_ZOUT_L[0]     |
     *                  |       5      | ACCEL_XOUT_L[0]    |
     *                  |       6      | ACCEL_YOUT_L[0]    |
     *                  |       7      | ACCEL_ZOUT_L[0]    |
     *                  -------------------------------------
     *
     * The DLPF is configured by DLPF_CFG. The accelerometer and gyroscope are
     * filtered according to the value of DLPF_CFG as shown in the table below.
     *
     * |----------------------------------------------------------------------------|
     * | DLPF_CFG |      Accelerometer      |                Gyroscope              |
     * |          |       (Fs = 1kHz)       |                                       |
     * |          |-------------------------|---------------------------------------|
     * |          | Bandwidth    | Delay    | Bandwidth    | Delay    | Fs (kHz)    |
     * |          | (Hz)         | (ms)     | (Hz)         | (ms)     |             |
     * |----------------------------------------------------------------------------|
     * |    0     |     260      |     0    |      256     |   0.98   |      8      |
     * |    1     |     184      |     0    |      188     |   0.98   |      1      |
     * |    2     |     94       |     0    |      98      |   0.98   |      1      |
     * |    3     |     44       |     0    |      42      |   0.98   |      1      |
     * |    4     |     21       |     0    |      20      |   0.98   |      1      |
     * |    5     |     10       |     0    |      10      |   0.98   |      1      |
     * |    6     |     5        |     0    |      5       |   0.98   |      1      |
     * |    7     |        RESERVED         |         RESERVED        |      8      |
     * |----------------------------------------------------------------------------|
     *
     * Bit 7 and bit 6 are reserved.
     *
     * Parameters:
     * -----------
     * EXT_FSYNC_SET   3-bit unsigned value. Configures the FSYNC pin sampling.
     * DLPF_CFG        3-bit unsigned value. Configures the DLPF setting.
     *
     * Usage: Disable FSYNC input and the Digital Low-pass Filter to get the
     * highest bandwidth and lowest time delay.
     */
    I2CInterface::Instance()->write8(0x1A, 0x00);

    /*
     * FIFO Enable: Address: 0x23
     *
     * Description:
     * ------------
     * This register determines which sensor measurements are loaded into the
     * FIFO buffer.
     *
     * Data stored inside the sensor data registers (Registers 59 to 96) will
     * be loaded into the FIFO buffer if a sensor’s respective FIFO_EN bit is
     * set to 1 in this register.
     *
     * When a sensor’s FIFO_EN bit is enabled in this register, data from the
     * sensor data registers will be loaded into the FIFO buffer. The sensors
     * are sampled at the Sample Rate as defined in Register 25. For further
     * information regarding sensor data registers, please refer to Registers
     * 59 to 96.
     *
     * When an external Slave’s corresponding FIFO_EN bit (SLVx_FIFO_EN, where
     * x=0, 1, or 2) is set to 1, the data stored in its corresponding data
     * registers (EXT_SENS_DATA registers, Registers 73 to 96) will be written
     * into the FIFO buffer at the Sample Rate. EXT_SENS_DATA register
     * association with I2C Slaves is determined by the I2C_SLVx_CTRL registers
     * (where x=0, 1, or 2; Registers 39, 42, and 45). For information
     * regarding EXT_SENS_DATA registers, please refer to Registers 73 to 96.
     *
     * Note that the corresponding FIFO_EN bit (SLV3_FIFO_EN) is found in
     * I2C_MST_CTRL (Register 36). Also note that Slave 4 behaves in a
     * different manner compared to Slaves 0-3. Please refer to Registers 49 to
     * 53 for further information regarding Slave 4 usage.
     *
     * Parameters:
     * -----------
     * TEMP_FIFO_EN   When set to 1, this bit enables TEMP_OUT_H and TEMP_OUT_L
     *                (Registers 65 and 66) to be written into the FIFO buffer.
     * XG_FIFO_EN     When set to 1, this bit enables GYRO_XOUT_H and
     *                GYRO_XOUT_L (Registers 67 and 68) to be written into the
     *                FIFO buffer.
     * YG_FIFO_EN     When set to 1, this bit enables GYRO_YOUT_H and
     *                GYRO_YOUT_L (Registers 69 and 70) to be written into the
     *                FIFO buffer.
     * ZG_FIFO_EN     When set to 1, this bit enables GYRO_ZOUT_H and
     *                GYRO_ZOUT_L (Registers 71 and 72) to be written into the
     *                FIFO buffer.
     * ACCEL_FIFO_EN  When set to 1, this bit enables ACCEL_XOUT_H,
     *                ACCEL_XOUT_L, ACCEL_YOUT_H, ACCEL_YOUT_L, ACCEL_ZOUT_H,
     *                and ACCEL_ZOUT_L (Registers 59 to 64) to be written into
     *                the FIFO buffer.
     * SLV2_FIFO_EN   When set to 1, this bit enables EXT_SENS_DATA registers
     *                (Registers 73 to 96) associated with Slave 2 to be
     *                written into the FIFO buffer.
     * SLV1_FIFO_EN   When set to 1, this bit enables EXT_SENS_DATA registers
     *                (Registers 73 to 96) associated with Slave 1 to be written
     *                into the FIFO buffer.
     * SLV0_FIFO_EN   When set to 1, this bit enables EXT_SENS_DATA registers
     *                (Registers 73 to 96) associated with Slave 0 to be
     *                written into the FIFO buffer.
     *
     * ￼Note: For further information regarding the association of
     * EXT_SENS_DATA registers to particular slave devices, please refer to
     * Registers 73 to 96.
     *
     * Usage: We are enable the Temp, Gyro & Accelerometer Sensor data
     */
    I2CInterface::Instance()->write8(0x23, 0xF8);

    /*
     * Interrupt Enable: Address 0x38
     *
     * Description:
     * ------------
     * This register enables interrupt generation by interrupt sources.
     *
     * For information regarding the interrupt status for of each interrupt
     * generation source, please refer to Register 58. Further information
     * regarding I2C Master interrupt generation can be found in Register 54.
     *
     * Bits 7, 5, 2 and 1 are reserved.
     *
     * Parameters:
     * -----------
     * IFO_OFLOW_EN    When set to 1, this bit enables a FIFO buffer overflow
     *                 to generate an interrupt.
     * I2C_MST_INT_EN  When set to 1, this bit enables any of the I2C Master
     *                 interrupt sources to generate an interrupt.
     * DATA_RDY_EN     When set to 1, this bit enables the Data Ready interrupt
     *                 which occurs each time a write operation to all of the
     *                 sensor registers has been completed.
     *
     * Usage: We want to enable the FIFO OFLOW_EN and DATA_RDY_EN interrupts.
     */
    I2CInterface::Instance()->write8(0x38, 0x19);

    /*
     * User Control: Address 0x6A
     *
     * Description:
     * ------------
     * This register allows the user to enable and disable the FIFO buffer, I2C
     * Master Mode, and primary I2C interface. The FIFO buffer, I2C Master,
     * sensor signal paths and sensor registers can also be reset using this
     * register.
     *
     * When I2C_MST_EN is set to 1, I2C Master Mode is enabled. In this mode,
     * the MPU-9150 acts as the I2C Master to the external sensor slave devices
     * on the auxiliary I2C bus. When this bit is cleared to 0, the auxiliary
     * I2C bus lines (AUX_DA and AUX_CL) are logically driven by the primary
     * I2C bus (SDA and SCL). This is a precondition to enabling Bypass Mode.
     * For further information regarding Bypass Mode, please refer to Register
     * 55.
     *
     * Always write 0 to I2C_IF_DIS for the MPU-9150.
     *
     * When the reset bits (FIFO_RESET, I2C_MST_RESET, and SIG_COND_RESET) are
     * set to 1, these reset bits will trigger a reset and then clear to 0.
     * Bits 7 and 3 are reserved.
     *
     * Parameters:
     * -----------
     * FIFO_EN         When set to 1, this bit enables FIFO operations.
     *                 When this bit is cleared to 0, the FIFO buffer is
     *                 disabled.
     *                 The FIFO buffer cannot be written to or read
     *                 from while disabled.
     * I2C_MST_EN      When set to 1, this bit enables I2C Master Mode.
     *                 When this bit is cleared to 0, the auxiliary I2C bus
     *                 lines (AUX_DA and AUX_CL) are logically driven by the
     *                 primary I2C bus (SDA and SCL).
     * I2C_IF_DIS      Always write this bit as zero.
     * FIFO_RESET      This bit resets the FIFO buffer when set to 1 while
     *                 FIFO_EN equals 0. This bit automatically clears to 0
     *                 after the reset has been triggered.
     * I2C_MST_RESET   This bit resets the I2C Master when set to 1 while
     *                 I2C_MST_EN equals 0.
     *                 This bit automatically clears to 0 after the reset has
     *                 been triggered.
     * SIG_COND_RESET  When set to 1, this bit resets the signal paths for all
     *                 sensors (gyroscopes, accelerometers, and temperature
     *                 sensor). This operation will also clear the sensor
     *                 registers. This bit automatically clears to 0 after the
     *                 reset has been triggered.
     *                 When resetting only the signal path (and not the sensor
     *                 registers), please use Register 104, SIGNAL_PATH_RESET.
     *
     * Usage: Enable the FIFO, Disable I2C Master Mode.
     */
    I2CInterface::Instance()->write8(0x6A, 0x40);
}

MPU9150::~MPU9150()
{
}

void MPU9150::WakeUp()
{
    // Clear the 'sleep' bit
    I2CInterface::Instance()->write8(MPU9150_PWR_MGMT_1, 0);
}

__u8 MPU9150::WhoAmI()
{
    return I2CInterface::Instance()->read8(MPU9150_WHO_AM_I);
}

__u16 MPU9150::GetAccelerometerX()
{
    return (I2CInterface::Instance()->read8(MPU9150_ACCEL_XOUT_H) << 8) |
            I2CInterface::Instance()->read8(MPU9150_ACCEL_XOUT_L);
}

__u16 MPU9150::GetAccelerometerY()
{
    return (I2CInterface::Instance()->read8(MPU9150_ACCEL_YOUT_H) << 8) |
            I2CInterface::Instance()->read8(MPU9150_ACCEL_YOUT_L);
}

__u16 MPU9150::GetAccelerometerZ()
{
    return (I2CInterface::Instance()->read8(MPU9150_ACCEL_ZOUT_H) << 8) |
            I2CInterface::Instance()->read8(MPU9150_ACCEL_ZOUT_L);
}

__u16 MPU9150::GetGyroscopeX()
{
    return (I2CInterface::Instance()->read8(MPU9150_GYRO_XOUT_H) << 8) |
            I2CInterface::Instance()->read8(MPU9150_GYRO_XOUT_L);
}

__u16 MPU9150::GetGyroscopeY()
{
    return (I2CInterface::Instance()->read8(MPU9150_GYRO_YOUT_H) << 8) |
            I2CInterface::Instance()->read8(MPU9150_GYRO_YOUT_L);
}

__u16 MPU9150::GetGyroscopeZ()
{
    return (I2CInterface::Instance()->read8(MPU9150_GYRO_ZOUT_H) << 8) |
            I2CInterface::Instance()->read8(MPU9150_GYRO_ZOUT_L);
}

__u16 MPU9150::GetCompassX()
{
    return (I2CInterface::Instance()->read8(MPU9150_CMPS_XOUT_H) << 8) |
            I2CInterface::Instance()->read8(MPU9150_CMPS_XOUT_L);
}

__u16 MPU9150::GetCompassY()
{
    return (I2CInterface::Instance()->read8(MPU9150_CMPS_YOUT_H) << 8) |
            I2CInterface::Instance()->read8(MPU9150_CMPS_YOUT_L);
}

__u16 MPU9150::GetCompassZ()
{
    return (I2CInterface::Instance()->read8(MPU9150_CMPS_ZOUT_H) << 8) |
            I2CInterface::Instance()->read8(MPU9150_CMPS_ZOUT_L);
}

__u16 MPU9150::GetTemp()
{
    return (I2CInterface::Instance()->read8(MPU9150_TEMP_OUT_H) << 8) |
            I2CInterface::Instance()->read8(MPU9150_TEMP_OUT_L);
}
