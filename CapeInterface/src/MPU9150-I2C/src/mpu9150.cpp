#include "mpu9150.h"

using namespace Sensors;

MPU9150::MPU9150(const __u8 bus, const __u16 address) :
    mDeviceAddr( address )
{
    // Open the bus and set the address to the MPU-9150
    I2CInterface::Instance()->OpenI2CInterface( bus );

    // Begin configuring the MPU-9150 for use

    /*
     * Sample Rate Divider: Address 0x19
     *
     * Description:
     * ------------
     * This register specifies the divider from the gyroscope output rate used
     * to generate the Sample Rate for the MPU-9150.
     *
     * The sensor register output,FIFO output and DMP sampling are all based on
     * the Sample Rate. The Sample Rate is generated by dividing the gyroscope
     * output rate by SMPLRT_DIV:
     *          Sample Rate = Gyroscope Output Rate / (1 + SMPLRT_DIV)
     * where Gyroscope Output Rate = 8kHz when the DLPF is disabled
     * (DLPF_CFG = 0 or 7), and 1kHz when the DLPF is enabled (see Register 26).
     *
     * Note: The accelerometer output rate is 1kHz. This means that for a
     * Sample Rate greater than 1kHz, the same accelerometer sample may be
     * output to the FIFO, DMP, and sensor registers more than once.
     *
     * Usage: We will set the value to 8 to get a sensor sample rate of 1kHz.
     * Since the accelerometer sample rate is 1kHz, we will set the sample rate
     * of the other data to 1kHz too.
     */
    I2CInterface::Instance()->write8(address, 0x19, 0x07);

    /*
     * Configuration: Address: 0x1A
     *
     * Description:
     * ------------
     * This register configures the external Frame Synchronization (FSYNC) pin
     * sampling and the Digital Low Pass Filter (DLPF) setting for both the
     * gyroscopes and accelerometers.
     *
     * An external signal connected to the FSYNC pin can be sampled by
     * configuring EXT_SYNC_SET.
     *
     * Signal changes to the FSYNC pin are latched so that short strobes may be
     * captured. The latched FSYNC signal will be sampled at the Sampling Rate,
     * as defined in register 25. After sampling, the latch will reset to the
     * current FSYNC signal state.
     *
     * The sampled value will be reported in place of the least significant bit
     * in a sensor data register determined by the value of EXT_SYNC_SET
     * according to the following table.
     *
     *                  -------------------------------------
     *                  | EXT_SYNC_SET | FSYNC Bit Location |
     *                  -------------------------------------
     *                  |       0      | Input Disabled     |
     *                  |       1      | TEMP_OUT_L[0]      |
     *                  |       2      | GYRO_XOUT_L[0]     |
     *                  |       3      | GYRO_YOUT_L[0]     |
     *                  |       4      | GYRO_ZOUT_L[0]     |
     *                  |       5      | ACCEL_XOUT_L[0]    |
     *                  |       6      | ACCEL_YOUT_L[0]    |
     *                  |       7      | ACCEL_ZOUT_L[0]    |
     *                  -------------------------------------
     *
     * The DLPF is configured by DLPF_CFG. The accelerometer and gyroscope are
     * filtered according to the value of DLPF_CFG as shown in the table below.
     *
     * |----------------------------------------------------------------------------|
     * | DLPF_CFG |      Accelerometer      |                Gyroscope              |
     * |          |       (Fs = 1kHz)       |                                       |
     * |          |-------------------------|---------------------------------------|
     * |          | Bandwidth    | Delay    | Bandwidth    | Delay    | Fs (kHz)    |
     * |          | (Hz)         | (ms)     | (Hz)         | (ms)     |             |
     * |----------------------------------------------------------------------------|
     * |    0     |     260      |     0    |      256     |   0.98   |      8      |
     * |    1     |     184      |     0    |      188     |   0.98   |      1      |
     * |    2     |     94       |     0    |      98      |   0.98   |      1      |
     * |    3     |     44       |     0    |      42      |   0.98   |      1      |
     * |    4     |     21       |     0    |      20      |   0.98   |      1      |
     * |    5     |     10       |     0    |      10      |   0.98   |      1      |
     * |    6     |     5        |     0    |      5       |   0.98   |      1      |
     * |    7     |        RESERVED         |         RESERVED        |      8      |
     * |----------------------------------------------------------------------------|
     *
     * Bit 7 and bit 6 are reserved.
     *
     * Parameters:
     * -----------
     * EXT_FSYNC_SET   3-bit unsigned value. Configures the FSYNC pin sampling.
     * DLPF_CFG        3-bit unsigned value. Configures the DLPF setting.
     *
     * Usage: Disable FSYNC input and the Digital Low-pass Filter to get the
     * highest bandwidth and lowest time delay.
     */
    I2CInterface::Instance()->write8(address, 0x1A, 0x00);

    /*
     * Gyroscope Configuration: Address 0x1B
     *
     * Description:
     * ------------
     * This register is used to trigger gyroscope self-test and configure the
     * gyroscopes’ full scale range.
     *
     * The self-test for each gyroscope axis can be activated by controlling
     * the XG_ST, YG_ST, and ZG_ST bits of this register. Self-test for each
     * axis may be performed independently or all at the same time. Please
     * refer to registers 13 – 16 for further information on gyroscope
     * self-test.
     *
     * This register is used to configure the gyroscopes’ full scale range.
     *
     * FS_SEL selects the full scale range of the gyroscope outputs according to the following table.
     *
     *                    |----------------------------|
     *                    | FS_SEL | Full Scale Range  |
     *                    |--------|-------------------|
     *                    |    0   | +/-250 degrees/s  |
     *                    |    1   | +/-500 degrees/s  |
     *                    |    2   | +/-1000 degrees/s |
     *                    |    3   | +/-2000 degrees/s |
     *                    |--------|-------------------|
     *
     * Bits 7 through 5 and 2 through 0 are reserved.
     *
     * Parameters:
     * -----------
     * FS_SEL 2-bit unsigned value. Selects the full scale range of gyroscopes.
     *
     * Usage: Set the range to +/- 1000 degrees/s
     */
    I2CInterface::Instance()->write8(address, 0x1B, 0x10);

    /*
     * Accelerometer Configuration: Address 0x1C
     *
     * Description:
     * ------------
     * This register is used to trigger accelerometer self-test and configure
     * the accelerometer full scale range.
     *
     * The self-test for each accelerometer axis can be activated by
     * controlling the XA_ST, YA_ST, and ZA_ST bits of this register. Self-test
     * for each axis may be performed independently or all at the same time.
     * Please refer to registers 13 – 16 for further information on
     * accelerometer self-test.
     *
     * AFS_SEL selects the full scale range of the accelerometer outputs
     * according to the following table.
     *
     * Usage: We are setting the range to +/-8g
     */
    I2CInterface::Instance()->write8(address, 0x1C, 0x10);

    /*
     * FIFO Enable: Address: 0x23
     *
     * Description:
     * ------------
     * This register determines which sensor measurements are loaded into the
     * FIFO buffer.
     *
     * Data stored inside the sensor data registers (Registers 59 to 96) will
     * be loaded into the FIFO buffer if a sensor’s respective FIFO_EN bit is
     * set to 1 in this register.
     *
     * When a sensor’s FIFO_EN bit is enabled in this register, data from the
     * sensor data registers will be loaded into the FIFO buffer. The sensors
     * are sampled at the Sample Rate as defined in Register 25. For further
     * information regarding sensor data registers, please refer to Registers
     * 59 to 96.
     *
     * When an external Slave’s corresponding FIFO_EN bit (SLVx_FIFO_EN, where
     * x=0, 1, or 2) is set to 1, the data stored in its corresponding data
     * registers (EXT_SENS_DATA registers, Registers 73 to 96) will be written
     * into the FIFO buffer at the Sample Rate. EXT_SENS_DATA register
     * association with I2C Slaves is determined by the I2C_SLVx_CTRL registers
     * (where x=0, 1, or 2; Registers 39, 42, and 45). For information
     * regarding EXT_SENS_DATA registers, please refer to Registers 73 to 96.
     *
     * Note that the corresponding FIFO_EN bit (SLV3_FIFO_EN) is found in
     * I2C_MST_CTRL (Register 36). Also note that Slave 4 behaves in a
     * different manner compared to Slaves 0-3. Please refer to Registers 49 to
     * 53 for further information regarding Slave 4 usage.
     *
     * Parameters:
     * -----------
     * TEMP_FIFO_EN   When set to 1, this bit enables TEMP_OUT_H and TEMP_OUT_L
     *                (Registers 65 and 66) to be written into the FIFO buffer.
     * XG_FIFO_EN     When set to 1, this bit enables GYRO_XOUT_H and
     *                GYRO_XOUT_L (Registers 67 and 68) to be written into the
     *                FIFO buffer.
     * YG_FIFO_EN     When set to 1, this bit enables GYRO_YOUT_H and
     *                GYRO_YOUT_L (Registers 69 and 70) to be written into the
     *                FIFO buffer.
     * ZG_FIFO_EN     When set to 1, this bit enables GYRO_ZOUT_H and
     *                GYRO_ZOUT_L (Registers 71 and 72) to be written into the
     *                FIFO buffer.
     * ACCEL_FIFO_EN  When set to 1, this bit enables ACCEL_XOUT_H,
     *                ACCEL_XOUT_L, ACCEL_YOUT_H, ACCEL_YOUT_L, ACCEL_ZOUT_H,
     *                and ACCEL_ZOUT_L (Registers 59 to 64) to be written into
     *                the FIFO buffer.
     * SLV2_FIFO_EN   When set to 1, this bit enables EXT_SENS_DATA registers
     *                (Registers 73 to 96) associated with Slave 2 to be
     *                written into the FIFO buffer.
     * SLV1_FIFO_EN   When set to 1, this bit enables EXT_SENS_DATA registers
     *                (Registers 73 to 96) associated with Slave 1 to be written
     *                into the FIFO buffer.
     * SLV0_FIFO_EN   When set to 1, this bit enables EXT_SENS_DATA registers
     *                (Registers 73 to 96) associated with Slave 0 to be
     *                written into the FIFO buffer.
     *
     * ￼Note: For further information regarding the association of
     * EXT_SENS_DATA registers to particular slave devices, please refer to
     * Registers 73 to 96.
     *
     * Usage: We are enable the Temp, Gyro & Accelerometer Sensor data
     */
    I2CInterface::Instance()->write8(address, 0x23, 0xF8);

    /*
     * Interrupt Pin / Bypass Enable Configuration: Address 0x37
     *
     * Description:
     * ------------
     * This register configures the behavior of the interrupt signals at the
     * INT pins. This register is also used to enable the FSYNC Pin to be used
     * as an interrupt to the host application processor, as well as to enable
     * Bypass Mode on the I2C Master. This bit also enables the clock output.
     *
     * FSYNC_INT_EN enables the FSYNC pin to be used as an interrupt to the
     * host application processor. A transition to the active level specified
     * in FSYNC_INT_LEVEL will trigger an interrupt. The status of this
     * interrupt is read from the PASS_THROUGH bit in the I2C Master Status
     * Register (Register 54).
     *
     * When I2C_BYPASS_EN is equal to 1 and I2C_MST_EN (Register 106 bit[5])
     * is equal to 0, the host application processor will be able to directly
     * access the auxiliary I2C bus of the MPU-9150. When this bit is equal to
     * 0, the host application processor will not be able to directly access
     * the auxiliary I2C bus of the MPU-9150 regardless of the state of
     * I2C_MST_EN.
     *
     * For further information regarding Bypass Mode, please refer to Section
     * 7.12 and 7.14 of the MPU- 9150 Product Specification document.
     *
     * Parameters:
     * -----------
     * NT_LEVEL         When this bit is equal to 0, the logic level for the
     *                  INT pin is active high.
     *                  When this bit is equal to 1, the logic level for the
     *                  INT pin is active low.
     *
     * INT_OPEN         When this bit is equal to 0, the INT pin is configured
     *                  as push-pull.
     *                  When this bit is equal to 1, the INT pin is configured
     *                  as open drain.
     *
     * LATCH_INT_EN     When this bit is equal to 0, the INT pin emits a 50us
     *                  long pulse.
     *                  When this bit is equal to 1, the INT pin is held high
     *                  until the interrupt is cleared.
     *
     * INT_RD_CLEAR     When this bit is equal to 0, interrupt status bits are
     *                  cleared only by reading INT_STATUS (Register 58)
     *                  When this bit is equal to 1, interrupt status bits are
     *                  cleared on any read operation.
     *
     * FSYNC_INT_LEVEL  When this bit is equal to 0, the logic level for the
     *                  FSYNC pin (when used as an interrupt to the host
     *                  processor) is active high.
     *                  When this bit is equal to 1, the logic level for the
     *                  FSYNC pin (when used as an interrupt to the host
     *                  processor) is active low.
     *
     * FSYNC_INT_EN     When equal to 0, this bit disables the FSYNC pin from
     *                  causing an interrupt to the host processor.
     *                  When equal to 1, this bit enables the FSYNC pin to be
     *                  used as an interrupt to the host processor.
     *
     * I2C_BYPASS_EN    When this bit is equal to 1 and I2C_MST_EN (Register
     *                  106 bit[5]) is equal to 0, the host application
     *                  processor will be able to directly access the auxiliary
     *                  I2C bus of the MPU-9150.
     *                  When this bit is equal to 0, the host application
     *                  processor will not be able to directly access the
     *                  auxiliary I2C bus of the MPU-9150 regardless of the
     *                  state of I2C_MST_EN (Register 106 bit[5]).
     *
     * Usage: We will enable I2C bypass, disable FSYNC interrupt, enable
     * interrupt any read clear, latch the interrupt line until cleared,
     * push-pull output and active high.
     */
    I2CInterface::Instance()->write8(address, 0x37, 0x32);

    /*
     * Interrupt Enable: Address 0x38
     *
     * Description:
     * ------------
     * This register enables interrupt generation by interrupt sources.
     *
     * For information regarding the interrupt status for of each interrupt
     * generation source, please refer to Register 58. Further information
     * regarding I2C Master interrupt generation can be found in Register 54.
     *
     * Bits 7, 5, 2 and 1 are reserved.
     *
     * Parameters:
     * -----------
     * IFO_OFLOW_EN    When set to 1, this bit enables a FIFO buffer overflow
     *                 to generate an interrupt.
     * I2C_MST_INT_EN  When set to 1, this bit enables any of the I2C Master
     *                 interrupt sources to generate an interrupt.
     * DATA_RDY_EN     When set to 1, this bit enables the Data Ready interrupt
     *                 which occurs each time a write operation to all of the
     *                 sensor registers has been completed.
     *
     * Usage: We want to enable the FIFO OFLOW_EN and DATA_RDY_EN interrupts.
     */
    I2CInterface::Instance()->write8(address, 0x38, 0x19);

    /*
     * User Control: Address 0x6A
     *
     * Description:
     * ------------
     * This register allows the user to enable and disable the FIFO buffer, I2C
     * Master Mode, and primary I2C interface. The FIFO buffer, I2C Master,
     * sensor signal paths and sensor registers can also be reset using this
     * register.
     *
     * When I2C_MST_EN is set to 1, I2C Master Mode is enabled. In this mode,
     * the MPU-9150 acts as the I2C Master to the external sensor slave devices
     * on the auxiliary I2C bus. When this bit is cleared to 0, the auxiliary
     * I2C bus lines (AUX_DA and AUX_CL) are logically driven by the primary
     * I2C bus (SDA and SCL). This is a precondition to enabling Bypass Mode.
     * For further information regarding Bypass Mode, please refer to Register
     * 55.
     *
     * Always write 0 to I2C_IF_DIS for the MPU-9150.
     *
     * When the reset bits (FIFO_RESET, I2C_MST_RESET, and SIG_COND_RESET) are
     * set to 1, these reset bits will trigger a reset and then clear to 0.
     * Bits 7 and 3 are reserved.
     *
     * Parameters:
     * -----------
     * FIFO_EN         When set to 1, this bit enables FIFO operations.
     *                 When this bit is cleared to 0, the FIFO buffer is
     *                 disabled.
     *                 The FIFO buffer cannot be written to or read
     *                 from while disabled.
     * I2C_MST_EN      When set to 1, this bit enables I2C Master Mode.
     *                 When this bit is cleared to 0, the auxiliary I2C bus
     *                 lines (AUX_DA and AUX_CL) are logically driven by the
     *                 primary I2C bus (SDA and SCL).
     * I2C_IF_DIS      Always write this bit as zero.
     * FIFO_RESET      This bit resets the FIFO buffer when set to 1 while
     *                 FIFO_EN equals 0. This bit automatically clears to 0
     *                 after the reset has been triggered.
     * I2C_MST_RESET   This bit resets the I2C Master when set to 1 while
     *                 I2C_MST_EN equals 0.
     *                 This bit automatically clears to 0 after the reset has
     *                 been triggered.
     * SIG_COND_RESET  When set to 1, this bit resets the signal paths for all
     *                 sensors (gyroscopes, accelerometers, and temperature
     *                 sensor). This operation will also clear the sensor
     *                 registers. This bit automatically clears to 0 after the
     *                 reset has been triggered.
     *                 When resetting only the signal path (and not the sensor
     *                 registers), please use Register 104, SIGNAL_PATH_RESET.
     *
     * Usage: Enable the FIFO, Disable I2C Master Mode.
     */
    I2CInterface::Instance()->write8(address, 0x6A, 0x40);
}

MPU9150::~MPU9150()
{
}

bool MPU9150::FIFOOverflow()
{
    __s8 data = I2CInterface::Instance()->read8(mDeviceAddr, MPU9150_INT_STATUS);
    if(data < 0)
        return false;
    else
        return (data & 0x10);
}

bool MPU9150::I2CMasterInterrupt()
{
    __s8 data = I2CInterface::Instance()->read8(mDeviceAddr, MPU9150_INT_STATUS);
    if(data < 0)
        return false;
    else
        return (data & 0x08);
}

bool MPU9150::DataReady()
{
    __s8 data = I2CInterface::Instance()->read8(mDeviceAddr, MPU9150_INT_STATUS);
    if(data < 0)
        return false;
    else
        return (data & 0x01);
}

void MPU9150::Sleep(bool enable)
{
    if( enable )
        I2CInterface::Instance()->write8(mDeviceAddr, MPU9150_PWR_MGMT_1, 0x40);
    else
        // Wake up the device and set the clock source to the X-axis gyroscope
        I2CInterface::Instance()->write8(mDeviceAddr, MPU9150_PWR_MGMT_1, 0x01);
}

__u8 MPU9150::WhoAmI()
{
    return I2CInterface::Instance()->read8(mDeviceAddr, MPU9150_WHO_AM_I);
}

__u16 MPU9150::GetAccelerometerX()
{
    return (I2CInterface::Instance()->read8(mDeviceAddr, MPU9150_ACCEL_XOUT_H) << 8) |
            I2CInterface::Instance()->read8(mDeviceAddr, MPU9150_ACCEL_XOUT_L);
}

__u16 MPU9150::GetAccelerometerY()
{
    return (I2CInterface::Instance()->read8(mDeviceAddr, MPU9150_ACCEL_YOUT_H) << 8) |
            I2CInterface::Instance()->read8(mDeviceAddr, MPU9150_ACCEL_YOUT_L);
}

__u16 MPU9150::GetAccelerometerZ()
{
    return (I2CInterface::Instance()->read8(mDeviceAddr, MPU9150_ACCEL_ZOUT_H) << 8) |
            I2CInterface::Instance()->read8(mDeviceAddr, MPU9150_ACCEL_ZOUT_L);
}

__u16 MPU9150::GetGyroscopeX()
{
    return (I2CInterface::Instance()->read8(mDeviceAddr, MPU9150_GYRO_XOUT_H) << 8) |
            I2CInterface::Instance()->read8(mDeviceAddr, MPU9150_GYRO_XOUT_L);
}

__u16 MPU9150::GetGyroscopeY()
{
    return (I2CInterface::Instance()->read8(mDeviceAddr, MPU9150_GYRO_YOUT_H) << 8) |
            I2CInterface::Instance()->read8(mDeviceAddr, MPU9150_GYRO_YOUT_L);
}

__u16 MPU9150::GetGyroscopeZ()
{
    return (I2CInterface::Instance()->read8(mDeviceAddr, MPU9150_GYRO_ZOUT_H) << 8) |
            I2CInterface::Instance()->read8(mDeviceAddr, MPU9150_GYRO_ZOUT_L);
}

__u16 MPU9150::GetCompassX()
{
    return (I2CInterface::Instance()->read8(mDeviceAddr, MPU9150_CMPS_XOUT_H) << 8) |
            I2CInterface::Instance()->read8(mDeviceAddr, MPU9150_CMPS_XOUT_L);
}

__u16 MPU9150::GetCompassY()
{
    return (I2CInterface::Instance()->read8(mDeviceAddr, MPU9150_CMPS_YOUT_H) << 8) |
            I2CInterface::Instance()->read8(mDeviceAddr, MPU9150_CMPS_YOUT_L);
}

__u16 MPU9150::GetCompassZ()
{
    return (I2CInterface::Instance()->read8(mDeviceAddr, MPU9150_CMPS_ZOUT_H) << 8) |
            I2CInterface::Instance()->read8(mDeviceAddr, MPU9150_CMPS_ZOUT_L);
}

__u16 MPU9150::GetTemp()
{
    return (I2CInterface::Instance()->read8(mDeviceAddr, MPU9150_TEMP_OUT_H) << 8) |
            I2CInterface::Instance()->read8(mDeviceAddr, MPU9150_TEMP_OUT_L);
}
